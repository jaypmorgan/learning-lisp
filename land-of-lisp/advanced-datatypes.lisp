;; Creating arrays
(defparameter x (make-array 3))

;; setting the value using setf
(setf (aref x 1) 'foo)

;; setf sets the value of an index using a generalised reference
;; an example is aref, but others can be second etc.
(setf foo '(a b c))
(second foo)
(setf (second foo) 'z)

(setf foo (make-array 4))
(setf (aref foo 2) '(x y z))
(setf (car (aref foo 2)) (make-hash-table))
(setf (gethash 'zoink (car (aref foo 2))) 5)

;; Hash tables
(defparameter x (make-hash-table))
(gethash 'yup x) ;; no key 'yup exists so NIL is retruned.  two nils
;; are returned, the nil being the value in the hash table, and the
;; second being whether the key was found


(setf (gethash 'yup x) '25)
(gethash 'yup x) ;; returns '25, T.

(defparameter *drink-order* (make-hash-table))
(setf (gethash 'bill *drink-order*) 'double-espresso)
(setf (gethash 'lisa *drink-order*) 'small-drip-coffee)
(setf (gethash 'john *drink-order*) 'medium-latte)

(defparameter *drink-order* (make-hash-table))
(let* ((orders '((bill double-espresso)
		 (lisa small-drip-coffee)
		 (john medium-latte))))
  (mapc (lambda (x) (setf (gethash (car x) *drink-order*) (cadr x)))
	orders))

(gethash 'bill *drink-order*)

;; Returning multiple values
;; we can return multiple values form a function using =values=
(defun foo ()
  (values 3 7))

;; lisp considers the first argument to be most important and so will
;; use it for follow up calculations
(+ (foo) 5) ;; => 8

;; if we want to retrieve both values:
(multiple-value-bind (a b) (foo) (* a b)) ;; => 21


;; Common Lisp Structures
(defstruct person
  name ;; properties or slots
  age
  waist-size
  favourite-colour)

(defparameter *bob* (make-person :name "Bob"
				 :age 35
				 :waist-size 32
				 :favourite-colour "blue"))

(person-age *bob*)  ;; getter method generated by the defstruct macro
(setf (person-age *bob*) 36) ;; set age

;; alternative to OOP strucutes with lists
(defun make-person (name age waist-size favourite-colour)
  (list name age waist-size favourite-colour))

(defun person-age (person)
  (cadr person))

(defparameter *bob* (make-person "bob" 35 32 "blue"))
(person-age *bob*)


;; Handling data in a generic way
;; finding the largest even number
(reduce (lambda (best item)
	  (if (and (evenp item)
		   (> item best))
	      item best))
	'(7 4 6 5 2)
	:initial-value 0)

;; map is a generic version of mapcar that only operates on
;; lists. With map, you must tell the function what type the result
;; will be.
(map 'list (lambda (x) (if (eq x #\s) #\S x)) "this is a string")
(map 'string (lambda (x) (if (eq x #\s) #\S x)) "this is a string")

(subseq "america" 2 6)

(sort '(5 8 2 4 9 3 6) #'<)

;; Creating generic functions with type predicates
(numberp 5)
(arrayp (make-array 5))

(defun add (a b)
  (cond ((and (numberp a) (numberp b)) (+ a b))
	((and (listp a) (listp b)) (append a b))))

(add 3 5)
(add '(a b) '(c d))

;; bad because: a single, monilithic function all types, modifications
;; required to accomodate new cases. Hard to understand and
;; performance.

;; better way using defmethod
(defmethod add ((a number) (b number))
  (+ a b))

(defmethod add ((a list) (b list))
  (append a b))

(add 3 5)
(add '(a b) '(c d))









